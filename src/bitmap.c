/*
 * bitmap.c
 * 
 * Copyright (c) 2003 Alexandre Pigolkine
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
 * and associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial 
 * portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT 
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Authors:
 *   Alexandre Pigolkine (pigolkine@gmx.de)
 *   Vladimir Vukicevic (vladimir@pobox.com)
 *   Jordi Mas (jordi@ximian.com)
 *   Jonathan Gilbert (logic@deltaq.org)
 */

#include <glib.h>
#include "gdip.h"
#include "gdipImage.h"
#include <string.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


/* The default indexed palettes. This code was generated by a tiny C# program.
 */

static const unsigned int default_Format1bppIndexed_palette[2] =
  {
    0x000000, 0xFFFFFF
  };
static const unsigned int default_Format4bppIndexed_palette[16] =
  {
    0x000000, 0x800000, 0x008000, 0x808000, 0x000080, 0x800080, 0x008080, 0x808080, 0xC0C0C0, 0xFF0000, 0x00FF00, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FFFF, 0xFFFFFF
  };
static const unsigned int default_Format8bppIndexed_palette[256] =
  {
    0x000000, 0x800000, 0x008000, 0x808000, 0x000080, 0x800080, 0x008080, 0x808080, 0xC0C0C0, 0xFF0000, 0x00FF00, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FFFF, 0xFFFFFF,
    0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
    0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000033, 0x000066, 0x000099, 0x0000CC, 0x0000FF, 0x003300, 0x003333,
    0x003366, 0x003399, 0x0033CC, 0x0033FF, 0x006600, 0x006633, 0x006666, 0x006699, 0x0066CC, 0x0066FF, 0x009900, 0x009933, 0x009966, 0x009999, 0x0099CC, 0x0099FF,
    0x00CC00, 0x00CC33, 0x00CC66, 0x00CC99, 0x00CCCC, 0x00CCFF, 0x00FF00, 0x00FF33, 0x00FF66, 0x00FF99, 0x00FFCC, 0x00FFFF, 0x330000, 0x330033, 0x330066, 0x330099,
    0x3300CC, 0x3300FF, 0x333300, 0x333333, 0x333366, 0x333399, 0x3333CC, 0x3333FF, 0x336600, 0x336633, 0x336666, 0x336699, 0x3366CC, 0x3366FF, 0x339900, 0x339933,
    0x339966, 0x339999, 0x3399CC, 0x3399FF, 0x33CC00, 0x33CC33, 0x33CC66, 0x33CC99, 0x33CCCC, 0x33CCFF, 0x33FF00, 0x33FF33, 0x33FF66, 0x33FF99, 0x33FFCC, 0x33FFFF,
    0x660000, 0x660033, 0x660066, 0x660099, 0x6600CC, 0x6600FF, 0x663300, 0x663333, 0x663366, 0x663399, 0x6633CC, 0x6633FF, 0x666600, 0x666633, 0x666666, 0x666699,
    0x6666CC, 0x6666FF, 0x669900, 0x669933, 0x669966, 0x669999, 0x6699CC, 0x6699FF, 0x66CC00, 0x66CC33, 0x66CC66, 0x66CC99, 0x66CCCC, 0x66CCFF, 0x66FF00, 0x66FF33,
    0x66FF66, 0x66FF99, 0x66FFCC, 0x66FFFF, 0x990000, 0x990033, 0x990066, 0x990099, 0x9900CC, 0x9900FF, 0x993300, 0x993333, 0x993366, 0x993399, 0x9933CC, 0x9933FF,
    0x996600, 0x996633, 0x996666, 0x996699, 0x9966CC, 0x9966FF, 0x999900, 0x999933, 0x999966, 0x999999, 0x9999CC, 0x9999FF, 0x99CC00, 0x99CC33, 0x99CC66, 0x99CC99,
    0x99CCCC, 0x99CCFF, 0x99FF00, 0x99FF33, 0x99FF66, 0x99FF99, 0x99FFCC, 0x99FFFF, 0xCC0000, 0xCC0033, 0xCC0066, 0xCC0099, 0xCC00CC, 0xCC00FF, 0xCC3300, 0xCC3333,
    0xCC3366, 0xCC3399, 0xCC33CC, 0xCC33FF, 0xCC6600, 0xCC6633, 0xCC6666, 0xCC6699, 0xCC66CC, 0xCC66FF, 0xCC9900, 0xCC9933, 0xCC9966, 0xCC9999, 0xCC99CC, 0xCC99FF,
    0xCCCC00, 0xCCCC33, 0xCCCC66, 0xCCCC99, 0xCCCCCC, 0xCCCCFF, 0xCCFF00, 0xCCFF33, 0xCCFF66, 0xCCFF99, 0xCCFFCC, 0xCCFFFF, 0xFF0000, 0xFF0033, 0xFF0066, 0xFF0099,
    0xFF00CC, 0xFF00FF, 0xFF3300, 0xFF3333, 0xFF3366, 0xFF3399, 0xFF33CC, 0xFF33FF, 0xFF6600, 0xFF6633, 0xFF6666, 0xFF6699, 0xFF66CC, 0xFF66FF, 0xFF9900, 0xFF9933,
    0xFF9966, 0xFF9999, 0xFF99CC, 0xFF99FF, 0xFFCC00, 0xFFCC33, 0xFFCC66, 0xFFCC99, 0xFFCCCC, 0xFFCCFF, 0xFFFF00, 0xFFFF33, 0xFFFF66, 0xFFFF99, 0xFFFFCC, 0xFFFFFF
  };


/*
	Those are the only pixel formats that we really support	
*/
BOOL
gdip_is_a_supported_pixelformat (PixelFormat fmt)
{
	switch (fmt) {
	
	case Format1bppIndexed:
	case Format4bppIndexed:
	case Format8bppIndexed:
 	case Format24bppRgb:
	case Format32bppArgb:
	case Format32bppPArgb:
	case Format32bppRgb:
		return TRUE;
	default:
		return FALSE;
	}
}

/*
	Returns TRUE if the Bitmap contains indexed (palettized) data.
*/
BOOL
gdip_is_an_indexed_pixelformat (PixelFormat fmt)
{
	return ((fmt & PixelFormatIndexed) != 0);
}

void 
gdip_bitmap_init (GpBitmap *bitmap)
{
	if (bitmap == NULL) {
		return;
	}

	memset(bitmap, 0, sizeof(GpBitmap));

	bitmap->type = imageBitmap;
	bitmap->image_format = INVALID;

	return;
}


GpStatus
gdip_propertyitems_clone(PropertyItem *src, PropertyItem **dest, int count)
{
	PropertyItem	*result;
	int		i;
	int		j;

	if (dest == NULL) {
		return InvalidParameter;
	}

	if (src == NULL) {
		*dest = NULL;
		return Ok;
	}
	result = GdipAlloc(sizeof(PropertyItem) * count);
	if (result == NULL) {
		return OutOfMemory;
	}

	for (i = 0; i < count; i++) {
		result[i].id = src[i].id;
		result[i].length = src[i].length;
		result[i].type = src[i].type;
		if ((src[i].value != NULL) && (src[i].length > 0)) {
			result[i].value = GdipAlloc(src[i].length);
			if (result[i].value == NULL) {
				for (j = 0; j < i; j++) {
					if (result[j].value != NULL) {
						GdipFree(result[j].value);
					}
				}
				return OutOfMemory;
			}
			
		} else {
			result[i].value = NULL;
		}
	}
	
	*dest = result;
	return Ok;
}

GpStatus
gdip_propertyitems_dispose(PropertyItem *property, int count)
{
	int i;

	if (property == NULL) {
		return Ok;
	}
	for (i = 0; i < count; i++) {
		if (property[i].value != NULL) {
			GdipFree(property[i].value);
		}
	}
	GdipFree(property);

	return Ok;
}


GpStatus
gdip_bitmapdata_init(BitmapData *data)
{
	if (data != NULL) {
		memset(data, 0, sizeof(BitmapData));
		return Ok;
	}
	return InvalidParameter;
}

GpStatus
gdip_bitmapdata_property_add_long(BitmapData *bitmap_data, PROPID id, guint32 value)
{
	unsigned char	buffer[4];

	buffer[0] = value & 0xff;
	buffer[1] = (value & 0x0000ff00) >> 8;
	buffer[2] = (value & 0x00ff0000) >> 16;
	buffer[3] = (value & 0xff000000) >> 24;

	return gdip_bitmapdata_property_add(bitmap_data, id, 4 , TypeLong, buffer);
}

GpStatus
gdip_bitmapdata_property_add_ASCII(BitmapData *bitmap_data, PROPID id, unsigned char *value)
{
	return gdip_bitmapdata_property_add(bitmap_data, id, strlen((char *)value) + 1, TypeASCII, value);
}

GpStatus
gdip_bitmapdata_property_add_byte(BitmapData *bitmap_data, PROPID id, int num_of_values, unsigned char *value)
{
	return gdip_bitmapdata_property_add(bitmap_data, id, num_of_values, TypeByte, value);
}

GpStatus
gdip_bitmapdata_property_add_short(BitmapData *bitmap_data, PROPID id, unsigned short value)
{
	unsigned char	buffer[2];

	buffer[0] = value & 0xff;
	buffer[1] = (value & 0x0ff00) >> 8;

	return gdip_bitmapdata_property_add(bitmap_data, id, 2, TypeShort, buffer);
}

GpStatus
gdip_bitmapdata_property_add_rational(BitmapData *bitmap_data, PROPID id, guint32 numerator, guint32 denominator)
{
	unsigned char	buffer[8];

	buffer[0] = numerator & 0xff;
	buffer[1] = (numerator & 0x0000ff00) >> 8;
	buffer[2] = (numerator & 0x00ff0000) >> 16;
	buffer[3] = (numerator & 0xff000000) >> 24;

	buffer[4] = denominator & 0xff;
	buffer[5] = (denominator & 0x0000ff00) >> 8;
	buffer[6] = (denominator & 0x00ff0000) >> 16;
	buffer[7] = (denominator & 0xff000000) >> 24;


	return gdip_bitmapdata_property_add(bitmap_data, id, 8, TypeRational, buffer);
}

GpStatus
gdip_bitmapdata_property_add_srational(BitmapData *bitmap_data, PROPID id, unsigned short numerator, unsigned short denominator)
{
	unsigned char	buffer[4];

	buffer[0] = numerator & 0xff;
	buffer[1] = (numerator & 0x0ff00) >> 8;

	buffer[2] = denominator & 0xff;
	buffer[3] = (denominator & 0xff00) >> 8;


	return gdip_bitmapdata_property_add(bitmap_data, id, 8, TypeRational, buffer);
}

GpStatus
gdip_bitmapdata_property_add(BitmapData *bitmap_data, PROPID id, ULONG length, WORD type, VOID *value)
{
	int	property_count;

	if (bitmap_data == NULL) {
		return InvalidParameter;
	}

	property_count = bitmap_data->property_count;

	if (bitmap_data->property == NULL) {
		bitmap_data->property = GdipAlloc(sizeof(PropertyItem));
	} else {
		bitmap_data->property = GdipRealloc(bitmap_data->property, sizeof(PropertyItem) * (property_count + 1));
	}
	if (bitmap_data->property == NULL) {
		bitmap_data->property_count = 0;
		return OutOfMemory;
	}

	if ((value != NULL) && (length > 0)) {
		bitmap_data->property[property_count].value = GdipAlloc(length);
		if (bitmap_data->property[property_count].value == NULL) {
			return OutOfMemory;
		}
		memcpy(bitmap_data->property[property_count].value, value, length);
	} else {
		bitmap_data->property[property_count].value = NULL;
	}

	bitmap_data->property[property_count].id = id;
	bitmap_data->property[property_count].length = length;
	bitmap_data->property[property_count].type = type;
	bitmap_data->property_count++;
	return Ok;
}

GpStatus
gdip_bitmapdata_property_remove_id(BitmapData *bitmap_data, PROPID id)
{
	int	i;

	for (i = 0; i < bitmap_data->property_count; i++) {
		if (bitmap_data->property[i].id == id) {
			return gdip_bitmapdata_property_remove_index(bitmap_data, i);
		}
	}

	return PropertyNotFound;
}

GpStatus
gdip_bitmapdata_property_remove_index(BitmapData *bitmap_data, int index)
{
	unsigned char *src;
	unsigned char *dest;

	if (index >= bitmap_data->property_count) {
		return PropertyNotFound;
	}

	/* We don't realloc the array, more overhead than savings */
	if ((index + 1) < bitmap_data->property_count) {
		if (bitmap_data->property[index].value != NULL) {
			GdipFree(bitmap_data->property[index].value);
		}
		memmove(&bitmap_data->property[index], &bitmap_data->property[index + 1], (bitmap_data->property_count - index - 1) * sizeof(PropertyItem));
	}
	bitmap_data->property_count--;

	return Ok;
}

GpStatus
gdip_bitmapdata_property_find_id(BitmapData *bitmap_data, PROPID id, int *index)
{
	int	i;

	if (index == NULL) {
		return InvalidParameter;
	}

	for (i = 0; i < bitmap_data->property_count; i++) {
		if (bitmap_data->property[i].id == id) {
			*index = i;
			return Ok;
		}
	}

	return PropertyNotFound;
}

GpStatus
gdip_bitmapdata_clone(BitmapData *src, BitmapData **dest, int count)
{
	GpStatus	status;
	BitmapData	*result;
	int		i;

	if (dest == NULL) {
		return InvalidParameter;
	}

	if (src == NULL) {
		*dest = NULL;
		return Ok;
	}

	result = GdipAlloc(sizeof(BitmapData) * count);
	if (result == NULL) {
		return OutOfMemory;
	}

	for (i = 0; i < count; i++) {
		result[i].width = src[i].width;
		result[i].height = src[i].height;
		result[i].stride = src[i].stride;
		result[i].pixel_format = src[i].pixel_format;
		result[i].reserved = GBD_OWN_SCAN0;	/* We're duplicating SCAN0, we always own it*/
		result[i].dpi_horz = src[i].dpi_horz;
		result[i].dpi_vert = src[i].dpi_vert;
		result[i].image_flags = src[i].image_flags;
		result[i].top = src[i].top;
		result[i].left = src[i].left;
		result[i].x = src[i].x;
		result[i].y = src[i].y;
		result[i].transparent = src[i].transparent;

		if (src[i].scan0 != NULL) {
			result[i].scan0 = GdipAlloc(src[i].stride * src[i].height);
			if (result[i].scan0 == NULL) {
				GdipFree(result);
				return OutOfMemory;
			}
			memcpy(result[i].scan0, src[i].scan0, src[i].stride * src[i].height);
		} else {
			result[i].scan0 = NULL;
		}

		/* Duplicate palette */
		if (src[i].palette != NULL) {
			result[i].palette = GdipAlloc(sizeof(ColorPalette) + sizeof(ARGB) * src[i].palette->Count);
			memcpy(result[i].palette, src[i].palette, sizeof(ColorPalette) + sizeof(ARGB) * src[i].palette->Count);
		} else {
			result[i].palette = NULL;
		}


		result[i].property_count = src[i].property_count;
		status = gdip_propertyitems_clone(src[i].property, &result[i].property, src[i].property_count);
		if (status != Ok) {
			int j;

			for (j = 0; j < i; j++) {
				if (result[j].scan0 != NULL) {
					GdipFree(result[j].scan0);
				}
				if (result[j].property != NULL) {
					gdip_propertyitems_dispose(result[j].property, result[j].property_count);
				}
			}

			GdipFree(result);
			return status;
		}
	}

	*dest = result;
	return Ok;
}

GpStatus
gdip_bitmapdata_dispose(BitmapData *bitmap, int count)
{
	int		index;

	if (bitmap == NULL) {
		return Ok;
	}

	for (index = 0; index < count; index++) {
		if ((bitmap[index].scan0 != NULL) && ((bitmap[index].reserved & GBD_OWN_SCAN0) != 0)) {
			GdipFree(bitmap[index].scan0);
		}

		if (bitmap[index].palette != NULL) {
			GdipFree(bitmap[index].palette);
		}

		gdip_propertyitems_dispose(bitmap[index].property, bitmap[index].property_count);
	}

	GdipFree(bitmap);
	return Ok;
}

/* Add a new frame for the given dimension, if it does not exist. Return pointer to frame for dimension */
FrameData *
gdip_frame_add(GpBitmap *bitmap, const GUID *dimension)
{
	int		i;

	if (bitmap == NULL) {
		return NULL;
	}

	if (bitmap->frames == NULL) {
		bitmap->frames = GdipAlloc(sizeof(FrameData));
		if (bitmap->frames == NULL) {
			return NULL;
		}

		bitmap->num_of_frames = 1;
		bitmap->frames[0].count = 0;
		bitmap->frames[0].bitmap = NULL;
		bitmap->frames[0].frame_dimension = *dimension;

		return bitmap->frames;
	} else {
		/* Check if this dimension already exists, if not, add it */
		for (i = 0; i < bitmap->num_of_frames; i++) {
			if (memcmp(&bitmap->frames[i].frame_dimension, dimension, sizeof(GUID)) == 0) {
				return &bitmap->frames[i];
			}
		}

		/* No frame for the requested dimension exists */
		bitmap->num_of_frames++;
		bitmap->frames = GdipRealloc(bitmap->frames, sizeof(FrameData) * (bitmap->num_of_frames));
		if (bitmap->frames == NULL) {
			return NULL;
		}
		bitmap->frames[bitmap->num_of_frames - 1].count = 0;
		bitmap->frames[bitmap->num_of_frames - 1].bitmap = NULL;
		bitmap->frames[bitmap->num_of_frames - 1].frame_dimension = *dimension;
			
		return &bitmap->frames[bitmap->num_of_frames - 1];
	}
}

/* Add a new BitmapData structure to an existing frame, return pointer to the new structure */
BitmapData *
gdip_frame_add_bitmapdata(FrameData *frame)
{
	if (frame == NULL) {
		return NULL;
	}

	if (frame->bitmap == NULL) {
		frame->bitmap = GdipAlloc(sizeof(BitmapData));
		if (frame->bitmap == NULL) {
			return NULL;
		}
		gdip_bitmapdata_init(frame->bitmap);
		frame->count++;
		return frame->bitmap;
	}

	frame->bitmap = GdipRealloc(frame->bitmap, sizeof(BitmapData) * (frame->count + 1));
	if (frame->bitmap == NULL) {
		return NULL;
	}
	gdip_bitmapdata_init(&frame->bitmap[frame->count]);
	frame->count++;
	return &frame->bitmap[frame->count - 1];
}

ColorPalette *
gdip_palette_clone(ColorPalette *original)
{
	ColorPalette *result;

	result = GdipAlloc(sizeof(ColorPalette) + sizeof(ARGB) * original->Count);
	if (result != NULL) {
		memcpy(result, original, sizeof(ColorPalette) + sizeof(ARGB) * original->Count);
	}

	return result;
}

GpStatus
gdip_bitmap_setactive(GpBitmap *bitmap, const GUID *dimension, int index)
{
	int	i;

	if (bitmap == NULL) {
		return InvalidParameter;
	}

	/* Invalidate the cached surface */
	if (bitmap->surface != NULL) {
		cairo_surface_destroy(bitmap->surface);
		bitmap->surface = NULL;
	}

	if ((bitmap->num_of_frames == 0) || (bitmap->frames == NULL)) {
		bitmap->active_frame = 0;
		bitmap->active_bitmap_no = 0;
		bitmap->active_bitmap = NULL;
		return Ok;
	}

	if (dimension == NULL) {
		if (bitmap->frames[0].count <= index) {
			return InvalidParameter;
		}
		bitmap->active_frame = 0;
		bitmap->active_bitmap_no = index;
		bitmap->active_bitmap = &bitmap->frames[0].bitmap[index];
		return Ok;
	}

	for (i = 0; i < bitmap->num_of_frames; i++) {
		if (memcmp(&bitmap->frames[i].frame_dimension, dimension, sizeof(GUID)) == 0) {
			if (bitmap->frames[i].count <= index) {
				return InvalidParameter;
			}
			bitmap->active_frame = i;
			bitmap->active_bitmap_no = index;
			bitmap->active_bitmap = &bitmap->frames[i].bitmap[index];
			return Ok;
		}
	}

	bitmap->active_frame = 0;
	bitmap->active_bitmap_no = 0;
	bitmap->active_bitmap = NULL;
	return InvalidParameter;
}

GpStatus
gdip_bitmap_clone (GpBitmap *bitmap, GpBitmap **clonedbitmap)
{
	GpBitmap	*result;
	int		frame;
	int		image;
	GpStatus	status;

	result = (GpBitmap *) GdipAlloc (sizeof (GpBitmap));
	if (result == NULL) {
		return OutOfMemory;
	}

	/* Copy simple types */
	result->type = bitmap->type;
	result->image_format = bitmap->image_format;
	result->num_of_frames = bitmap->num_of_frames;
	result->active_frame = bitmap->active_frame;
	result->active_bitmap_no = bitmap->active_bitmap_no;
	result->active_bitmap = NULL;
	result->cairo_format = bitmap->cairo_format;
	result->surface = NULL;

	/* Allocate and copy frames, properties and bitmap data */
	if (bitmap->frames != NULL) {
		result->frames = GdipAlloc(sizeof (FrameData) * result->num_of_frames);
		for (frame = 0; frame < result->num_of_frames; frame++) {
			result->frames[frame].count = bitmap->frames[frame].count;
			result->frames[frame].frame_dimension = bitmap->frames[frame].frame_dimension;
			result->frames[frame].bitmap = NULL;

			for (image = 0; image < bitmap->frames[frame].count; image++) {
				status = gdip_bitmapdata_clone(bitmap->frames[frame].bitmap, &result->frames[frame].bitmap, bitmap->frames[frame].count);
				if (status != Ok) {
					goto fail;
				}
			}
		}
		result->active_bitmap = &result->frames[result->active_frame].bitmap[result->active_bitmap_no];
	} else {
		bitmap->frames = NULL;
	}

	*clonedbitmap = result;
	return Ok;

fail:
	gdip_bitmap_dispose(result);
	return status;
}


GpBitmap *
gdip_bitmap_new(void)
{
	GpBitmap *result;

	result = (GpBitmap *) GdipAlloc (sizeof (GpBitmap));
	if (result != NULL) {
		gdip_bitmap_init (result);
	}

	return result;
}

/* Create a new bitmap, and create a frame with the given dimension */
GpBitmap *
gdip_bitmap_new_with_frame(const GUID *dimension, bool add_bitmapdata)
{
	GpBitmap	*result;
	FrameData	*frame;

	if (dimension == NULL) {
		dimension = &gdip_image_frameDimension_page_guid;
	}

	result = gdip_bitmap_new();
	if (result != NULL) {
		frame = gdip_frame_add(result, dimension);
		if ((frame != NULL) && add_bitmapdata) {
			BitmapData	*bitmap_data;

			bitmap_data = gdip_frame_add_bitmapdata(frame);
			if (bitmap_data != NULL) {
				result->active_bitmap = bitmap_data;
			}
		}
	}
	return result;
}

void 
gdip_bitmap_dispose (GpBitmap *bitmap)
{
	int frame;
	int image;

	/* Might be called with partially filled bitmaps, so check values to be freed instead of assuming */

	if (bitmap == NULL) {
		return;
	}

	if (bitmap->frames != NULL) {
		for (frame = 0; frame < bitmap->num_of_frames; frame++) {
			gdip_bitmapdata_dispose(bitmap->frames[frame].bitmap, bitmap->frames[frame].count);
		}
		GdipFree(bitmap->frames);
	}

	if (bitmap->surface != NULL) {
		cairo_surface_destroy(bitmap->surface);
	}

	if (bitmap != NULL) {
		GdipFree(bitmap);
	}
}

GpStatus
GdipCreateBitmapFromFile (GDIPCONST WCHAR* filename, GpBitmap **bitmap)
{
	return GdipLoadImageFromFile (filename, (GpImage **) bitmap);
}

GpStatus 
GdipCreateBitmapFromFileICM (GDIPCONST WCHAR* filename, GpBitmap **bitmap)
{
	return GdipCreateBitmapFromFile (filename, bitmap);
}

GpStatus 
GdipCreateBitmapFromScan0 (int width, int height, int stride, int format, void *scan0, GpBitmap **bitmap)
{
	GpStatus	status;
	FrameData	*frame;
	GpBitmap	*result;
	BitmapData	*bitmap_data;
	int		cairo_format;
	
	if (width <= 0 || height <= 0) {
		return InvalidParameter;
	}
	
	switch (format) {
		case Format24bppRgb: {
			cairo_format = CAIRO_FORMAT_RGB24;  
			break;
		}

		case Format32bppArgb:
		case Format32bppRgb:
		case Format32bppPArgb: {
			cairo_format = CAIRO_FORMAT_ARGB32;
			break;
		}

		case Format8bppIndexed:
		case Format4bppIndexed: {
			cairo_format = CAIRO_FORMAT_A8;        
			break;
		}

		case Format1bppIndexed: {
			cairo_format = CAIRO_FORMAT_A1;
			break;
		}

		default: {
			*bitmap = NULL;
			return NotImplemented;
		}
	}

	result = gdip_bitmap_new ();
	if (result == NULL) {
		return OutOfMemory;
	}

	result->image_format = BMP;
	result->cairo_format = cairo_format;
	result->surface = NULL;
	result->active_frame = 0;
	result->active_bitmap_no = 0;
	result->active_bitmap = NULL;

	/* Create single 'page' frame, with single bitmap */
	frame = gdip_frame_add(result, &gdip_image_frameDimension_page_guid);
	if (frame == NULL) {
		status = OutOfMemory;
		goto fail;
	}

	bitmap_data = gdip_frame_add_bitmapdata(frame);
	if (bitmap_data == NULL) {
		status = OutOfMemory;
		goto fail;
	}

	/* populate first bitmap in first frame */
	bitmap_data->width = width;
	bitmap_data->height = height;
	bitmap_data->pixel_format = format;

	if (stride == 0) {
		if (gdip_is_an_indexed_pixelformat(format)) {
			stride = ((gdip_get_pixel_format_depth(format) * width) + 7) / 8;
		} else {
			stride = (gdip_get_pixel_format_components (format) * gdip_get_pixel_format_depth (format) * width) / 8;
		}

		/* make sure the stride aligns the next row to a pixman_bits_t boundary */
		stride += (sizeof(pixman_bits_t)-1);
		stride &= ~(sizeof(pixman_bits_t)-1);
	}
	bitmap_data->stride = stride;

	if (scan0 == NULL) {
		scan0 = GdipAlloc (stride * height);
		if (scan0 == NULL) {
			status = OutOfMemory;
			goto fail;
		}

		if ((gdip_get_pixel_format_bpp(format) < 16) || gdip_is_an_alpha_pixelformat(format)) {
			memset (scan0, 0, stride * height);
		} else {
			/* Since the pixel format is not an alpha pixel format (i.e., it is
			 * either Format24bppRgb or Format32bppRgb), the image should be
			 * initially black, not initially transparent. Thus, we need to set
			 * the alpha channel, which the user code doesn't think exists but
			 * Cairo is still paying attention to, to 0xFF.
			 */
			int	x;
			int	y;
			ARGB	solid_black;
			ARGB	*scan;

			/* Make sure the alpha channel is at the right end of the word. */
			set_pixel_bgra (&solid_black, 0, 0, 0, 0, 0xFF);

			for (y=0; y < height; y++) {
				scan = (ARGB *)((char *)scan0 + y * stride);
				for (x=0; x < width; x++) {
					scan[x] = solid_black;
				}
			}
		}
	}
	
	
	bitmap_data->scan0 = scan0;
	bitmap_data->reserved = GBD_OWN_SCAN0;	

	/* Make sure indexed images have a palette */
	if (gdip_is_an_indexed_pixelformat (format)) {
		int			palette_entries;
		int			header_size;
		int			bytes_needed;
		const unsigned int	*default_palette;
		int			i;

		palette_entries = 1 << gdip_get_pixel_format_depth(format);
		header_size = sizeof(ColorPalette) - sizeof(ARGB);
		bytes_needed = header_size + palette_entries * sizeof(ARGB);

		bitmap_data->palette = GdipAlloc (bytes_needed);

		if (bitmap_data->palette == NULL) {
			status = OutOfMemory;
			goto fail;
		}

		bitmap_data->palette->Flags = 0;
		bitmap_data->palette->Count = palette_entries;

		switch (format) {
			case Format1bppIndexed: default_palette = default_Format1bppIndexed_palette; break;
			case Format4bppIndexed: default_palette = default_Format4bppIndexed_palette; break;
			case Format8bppIndexed: default_palette = default_Format8bppIndexed_palette; break;
			default: default_palette = NULL;	// Suppress unassigned val used warning
		}

		for (i=0; i < palette_entries; i++) {
			set_pixel_bgra (bitmap_data->palette->Entries, i * 4,
				0xFF & (default_palette[i] >> 16),
				0xFF & (default_palette[i] >>  8),
				0xFF &  default_palette[i]       ,
				0xFF /* alpha */);
		}
	} else {
		bitmap_data->palette = NULL;
	}

	gdip_bitmap_setactive(result, NULL, 0);
	*bitmap = result;
	return Ok;

fail:
	gdip_bitmap_dispose(result);
	return status;
}

GpStatus
GdipCreateBitmapFromGraphics (int width, int height, GpGraphics *graphics, GpBitmap **bitmap)
{
	GpBitmap 	*result;
	FrameData	*frame;
	BitmapData	*bitmap_data;
	int 		stride;

	stride = width * 4 + (sizeof(pixman_bits_t)-1);
	stride &= ~(sizeof(pixman_bits_t)-1);
	
	result = gdip_bitmap_new ();
	result->image_format = BMP;
	result->cairo_format = CAIRO_FORMAT_ARGB32;

	frame = gdip_frame_add(result, &gdip_image_frameDimension_page_guid);
	if (frame == NULL) {
		goto fail;
	}

	bitmap_data = gdip_frame_add_bitmapdata(frame);
	if (bitmap_data == NULL) {
		goto fail;
	}

	bitmap_data->width = width;
	bitmap_data->height = height;
	bitmap_data->stride = stride;
	bitmap_data->pixel_format = Format32bppArgb;
	bitmap_data->reserved = GBD_OWN_SCAN0;
	bitmap_data->scan0 = GdipAlloc(stride * height);
	if (bitmap_data->scan0 == NULL) {
		goto fail;
	}

	gdip_bitmap_setactive(result, NULL, 0);

	*bitmap = result;
	return Ok;

fail:
	gdip_bitmap_dispose(result);
	return OutOfMemory;
}

GpStatus
GdipCreateBitmapFromHBITMAP(void *hbm, void *hpal, GpBitmap** bitmap)
{
	return GdipCloneImage((GpImage *)hbm, (GpImage **)bitmap);
}

GpStatus
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap, void **hbmReturn, unsigned long background)
{
	*hbmReturn = bitmap;
	return Ok;
}

GpStatus
GdipCreateBitmapFromHICON(void *hicon, GpBitmap** bitmap)
{
	return(NotImplemented);
}

GpStatus
GdipCreateHICONFromBitmap(GpBitmap* bitmap, void **hbmReturn)
{
	return(NotImplemented);
}

GpStatus
GdipCreateBitmapFromResource(void *hInstance, GDIPCONST WCHAR *lpBitmapName, GpBitmap** bitmap)
{
	return(NotImplemented);
}

GpStatus
GdipCloneBitmapAreaI (int x, int y, int width, int height, PixelFormat format,
					  GpBitmap *original, GpBitmap **bitmap)
{
	GpBitmap	*result;
	FrameData	*frame;
	BitmapData	*bitmap_data;
	Rect		sr = { x, y, width, height };
	Rect		dr = { 0, 0, width, height };
	GpStatus	status;

	if ((original == NULL) || (bitmap == NULL) || (original->active_bitmap == NULL)) {
		return InvalidParameter;
	}

	if (((x + width) > original->active_bitmap->width) || ((y + height) > original->active_bitmap->height)) {
		return InvalidParameter;
	}

	result = gdip_bitmap_new_with_frame(NULL, TRUE);
	if (result == NULL) {
		return OutOfMemory;
	}

	status = gdip_bitmap_clone_data_rect (original->active_bitmap, &sr, result->active_bitmap, &dr);
	if (status != Ok) {
		goto fail;
	}

	result->cairo_format = original->cairo_format;
		
	gdip_bitmap_setactive(result, NULL, result->frames[0].count - 1);
	*bitmap = result;
	return Ok;

fail:
	return status;
}

GpStatus
GdipCloneBitmapArea (float x, float y, float w, float h, PixelFormat format,
					 GpBitmap *original, GpBitmap **bitmap)
{
	return GdipCloneBitmapAreaI ((int) x, (int) y, (int) w, (int) h, format,
								 original, bitmap);
}

static void
gdip_copy_strides (void *dst, int dstStride, void *src, int srcStride, int realBytes, int height)
{
	int i;
	for (i = 0; i < height; i++) {
		memcpy (dst, src, realBytes);
		dst += dstStride;
		src += srcStride;
	}
}

/*
 * Copy srcRect region in srcData to destRect region in destData.  No conversion is done.  Assumes
 * BitmapData is straight from a GpBitmap.  src and dest rects must be the same width/height and
 * bits must be of the same PixelFormat.
 */

GpStatus
gdip_bitmap_clone_data_rect (GdipBitmapData *srcData, Rect *srcRect, GdipBitmapData *destData, Rect *destRect)
{
	int dest_components;
	int dest_depth; 

	if ((srcData == NULL) || (srcRect == NULL) || (destData == NULL) || (destRect == NULL) || (srcRect->Width != destRect->Width) || (srcRect->Height != destRect->Height)) {
		return InvalidParameter;
	}
	
	if (!gdip_is_a_supported_pixelformat (srcData->pixel_format)) {
		return NotImplemented;
	}
	
	dest_components = gdip_get_pixel_format_components (destData->pixel_format);
	dest_depth = gdip_get_pixel_format_depth (destData->pixel_format);

	if (destData->scan0 == NULL) {
		destData->stride = (((( destRect->Width * dest_components * dest_depth) /8) + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1));

		destData->scan0 = GdipAlloc (destData->stride * destRect->Height);
		if (destData== NULL) {
			return OutOfMemory;
		}
		
		destData->width = destRect->Width;
		destData->height = destRect->Height;
		destData->pixel_format = srcData->pixel_format;
		destData->reserved = GBD_OWN_SCAN0;

		if (srcData->palette != NULL) {
			destData->palette = GdipAlloc(sizeof(ColorPalette) + sizeof(ARGB) * srcData->palette->Count);
			if (destData->palette == NULL) {
				GdipFree(destData->scan0);
				destData->scan0 = NULL;
				return OutOfMemory;
			}
			memcpy(destData->palette, srcData->palette, sizeof(ColorPalette) + sizeof(ARGB) * srcData->palette->Count);
		}
	}


	if (!gdip_is_an_indexed_pixelformat (srcData->pixel_format)) {
		gdip_copy_strides (destData->scan0, destData->stride,
			srcData->scan0 + (srcData->stride * srcRect->Y) + (gdip_get_pixel_format_components (srcData->pixel_format) 
			* srcRect->X), srcData->stride,   destRect->Width * dest_components,  destRect->Height);
	} else {
		int src_depth;
		int src_first_x_bit_index;
		int width_bits;
		int src_first_x_bit_offset_into_byte;

		src_depth = gdip_get_pixel_format_depth (srcData->pixel_format);

		/* first, check if the bits are aligned onto a byte boundary */
		src_first_x_bit_index = srcRect->X * src_depth;
		width_bits = destRect->Width * src_depth;
		src_first_x_bit_offset_into_byte = src_first_x_bit_index & 7;

		if (src_first_x_bit_offset_into_byte == 0) {
			/* the fast path: no mid-byte bit mangling required :-)
			 * this will always be the case for 8-bit images.
			 * basically, the source bits are aligned to the destination
			 * bytes, and it doesn't matter if the width isn't a multiple
			 * of 8 bits, because the remainder is guaranteed to be
			 * allocated by the stride, and will be ignored because the
			 * width will indicate fewer pixels than actually end up being
			 * copied.
			 */
			gdip_copy_strides (
				destData->scan0, destData->stride,
				srcData->scan0 + (src_first_x_bit_index / 8) + (srcData->stride * srcRect->Y),
				srcData->stride, width_bits / 8, destRect->Height);
		} else {
			/* the not-so-fast path: no bits are aligned, so the entire image requires bit juggling. */

			unsigned char	*src_scan;
			unsigned char	*src_scan0;
			unsigned char	*dest_scan;
			unsigned char	*dest_scan0;
			unsigned short	buffer;
			int		left_shift;
			int		x;
			int		y;

			src_scan0 = srcData->scan0;
			dest_scan0 = destData->scan0;
			left_shift = src_first_x_bit_offset_into_byte;

			/* move the src_scan0 up to the first byte with pixel data involved in the copy */
			src_scan0 += srcRect->Y * srcData->stride;
			src_scan0 += (src_first_x_bit_offset_into_byte / 8);

			for (y=0; y < destRect->Height; y++) {
				src_scan = src_scan0 + y * srcData->stride;
				dest_scan = dest_scan0 + y * destData->stride;

				/* jump-start the packing function. it avoids double-sampling the source bits by
				 * using buffer as a shift register; bits 8-15 are the current packed dest pixel,
				 * and some of bits 0-7 are not used, to permit alignment of the pixel data.
				 */
				buffer = src_scan[0] << left_shift;

				for (x = 1; x < destRect->Width; x++) {
					buffer <<= 8;
					buffer |= src_scan[x] << left_shift;
					dest_scan[0] = (buffer >> 8);
				}
			}
		}
	}

	return Ok;
}

/*
 * According to GDI+ testing,
 * RGB[A] PixelFormats can be converted to/from any other RGB[A] pixel format, with or without alpha.
 * We should support all of these:
 *
 * 32bpp argb - 16bpp argb 1555
 * 32bpp argb - 16bpp rgb 555
 * 32bpp argb - 16bpp rgb 565
 * 32bpp argb - 24bpp rgb 888
 * 32bpp argb - 32bpp Pargb
 * 32bpp argb - 32bpp rgb
 *
 * Upconversion is allowed (e.g 8bpp indexed to 32bpp rgb), but no downconversion (32bpp to 8bpp indexed)
 *
 */

static int
gdip_is_pixel_format_conversion_valid (PixelFormat src, PixelFormat dest)
{
	if (src == dest) {
		return 1;
	}

	/* non-GDI supported formats can't be converted */
	if (!(src & PixelFormatGDI)) {
		return 0;
	}

	/* We don't allow converting *to* indexed formats */
	if (dest & PixelFormatIndexed) {
		return 0;
	}

	/* These are the RGB formats */
	if ((src & PixelFormatGDI) && !(src & PixelFormatExtended)) {
		/* all of these should be supported, but we only report the
		 * ones we really can do for now */
		/* We can't handle converting to/from the 565/555/1555 ones */
		if ((src & 0xff00) == 16 || (dest & 0xff00) == 16) {
			return 0;
		}
		return 1;
	}

	return 0;
}

/* Format24bppRgb is internally stored by Cairo as a four bytes. Convert it to 3-byte (RGB) */	
int
gdip_from_ARGB_to_RGB (BYTE *src, int width, int height, int stride, BYTE **dest, int* dest_stride)
{
	int	x;
	int	y;
	BYTE	*result;
	BYTE	*pos_src;
	BYTE	*pos_dest;
	int	src_components = 4; /* ARGB */
	int	dest_components = 3; /* RGB */
	
	*dest_stride = dest_components * 8;
	*dest_stride = (*dest_stride * width) / 8;
	*dest_stride = (*dest_stride + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1);		
	
	result = GdipAlloc (*dest_stride * height);
	if (result == NULL) {
		return OutOfMemory;
	}
	
	memset (result, 0, *dest_stride * height);
	
	for (y = 0, pos_src = src, pos_dest = result; y < height; y++, pos_src += stride, pos_dest += *dest_stride) {		
		for (x = 0; x < width; x++) {
			pos_dest[0 + (dest_components * x)] = pos_src[0 + (src_components * x)];
			pos_dest[1 + (dest_components * x)] = pos_src[1 + (src_components * x)];
			pos_dest[2 + (dest_components * x)] = pos_src[2 + (src_components * x)];
		}
	}
	
	*dest = result;
	return Ok;
}


/* Format24bppRgb is internally stored by Cairo as a three bytes. Convert it to 4-byte (ARGB) */	
int
gdip_from_RGB_to_ARGB (BYTE *src, int width, int height, int stride, BYTE **dest, int* dest_stride)
{
	int	x;
	int	y;
	BYTE	*result;
	BYTE	*pos_src;
	BYTE	*pos_dest;
	int	src_components = 3; /* RGB */
	int	dest_components = 4; /* ARGB */
	
	*dest_stride = dest_components * 8;
	*dest_stride = (*dest_stride * width) / 8;
	*dest_stride = (*dest_stride + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1);		
	
	result = GdipAlloc (*dest_stride * height);
	if (result == NULL) {
		return OutOfMemory;
	}
	
	memset (result, 0, *dest_stride * height);
	
	for (y = 0, pos_src = src, pos_dest = result; y < height; y++, pos_src += stride, pos_dest += *dest_stride) {		
		for (x = 0; x < width; x++) {
			pos_dest[0 + (dest_components * x)] = pos_src[0 + (src_components * x)];
			pos_dest[1 + (dest_components * x)] = pos_src[1 + (src_components * x)];
			pos_dest[2 + (dest_components * x)] = pos_src[2 + (src_components * x)];
			pos_dest[3 + (dest_components * x)] = 0xff;
		}
	}
	
	*dest = result;
	return Ok;
}

GpStatus
gdip_init_pixel_stream (StreamingState *state, BitmapData *data, int x, int y, int w, int h)
{
	if ((state == NULL) || (data == NULL) || (data->scan0 == NULL)) {
		return InvalidParameter;
	}

	/* Ensure that the rectangle requested is legal. */
	if ((x < 0) || (y < 0) || ((x + w) > data->width) || ((y + h) > data->height)) {
		return InvalidParameter;
	}

	/* Initialize the StreamingState structure to point at the first pixel. */
	state->region.X = x;
	state->region.Y = y;
	state->region.Width = w;
	state->region.Height = h;

	state->x = x;
	state->y = y;

	state->p = -1; /* ensure that the buffer will be preloaded on the first call, for indexed formats */

	switch (data->pixel_format) {
		case Format1bppIndexed: state->one_pixel_mask = 0x01; state->one_pixel_shift = 1; state->pixels_per_byte = 8; break;
		case Format4bppIndexed: state->one_pixel_mask = 0x0F; state->one_pixel_shift = 4; state->pixels_per_byte = 2; break;
		case Format8bppIndexed: state->one_pixel_mask = 0xFF; state->one_pixel_shift = 8; state->pixels_per_byte = 1; break;
		case Format24bppRgb: { /* gdip_get_pixel_format_bpp lies because other code depends on Format24bppRgb being CAIRO_FORMAT_ARGB32 internally */
			state->pixels_per_byte = -3;
			break;
		}

		default: {
			/* indicate full RGB processing */
			state->pixels_per_byte = -gdip_get_pixel_format_bpp (data->pixel_format) / 8; 
			break;
		}
	}

	state->data = data;

	/* The following computation will compute the byte pointer that _contains_ the first
	 * pixel; this doesn't necessarily mean that the pixel is aligned to the byte. This
	 * will be handled in gdip_pixel_stream_get_next () each time it starts a new row.
	 */
	state->scan = (unsigned char *)(data->scan0)
			+ y * data->stride
			+ x * gdip_get_pixel_format_bpp (data->pixel_format) / 8;

	return Ok;
}

BOOL
gdip_pixel_stream_has_next (StreamingState *state)
{
	if (state != NULL) {
		return (state->p >= 0)
		    || ((state->y < (state->region.Y + state->region.Height))
		     && (state->x < (state->region.X + state->region.Width)));
	} else {
		return FALSE;
	}
}

unsigned int /* <-- can be an ARGB or a palette index */
gdip_pixel_stream_get_next (StreamingState *state)
{
	unsigned int ret;

	if (state == NULL) {
		int bright_pink;
		set_pixel_bgra(&bright_pink, 0,
			0xFF, 0x00, 0xFF, 0xFF); /* bright pink; hopefully this will get somebody's attention :-) */
		return bright_pink;
	}

	/* Note: This function does not check whether the end of the region has been hit. This function can
	 * potentially overrun memory buffers! gdip_pixel_stream_has_next () must be used in conjunction
	 * with this function.
	 */

	if (state->pixels_per_byte == 1) {
		/* A fast path for 8-bit indexed data: pixels are byte-aligned, so no special unpacking is required. */
		ret = *state->scan;

		state->scan++;
		state->x++;

		if (state->x >= (state->region.X + state->region.Width)) {
			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x;
		}
	} else if (state->pixels_per_byte > 0) {
		/* We have an indexed format (the RGB formats can't fit a whole pixel into a single byte). */
		if (state->p < 0) {
			state->buffer = *state->scan;
			state->scan++;
			state->p = 0;

			if (state->x == state->region.X) {
				/* First pixel of the row; check whether it is aligned to the byte or not. */
				int index_into_byte = state->x & (state->pixels_per_byte - 1);

				if (index_into_byte != 0) {
					/* Not aligned; need to advance the buffer to the
					 * first pixel in the stream region.
					 */
					state->buffer <<= (index_into_byte * state->one_pixel_shift);
					state->p = index_into_byte;
				}
			}
		}

		state->buffer <<= state->one_pixel_shift;

		ret = (state->buffer >> 8) & state->one_pixel_mask;

		state->x++;
		state->p++;

		/* Have we hit the end of the buffer? */
		if (state->p >= state->pixels_per_byte)	
			state->p = -1;

		if (state->x >= (state->region.X + state->region.Width)) {
			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x * gdip_get_pixel_format_bpp (state->data->pixel_format) / 8;

			state->p = -1;
		}
	} else {
		/* We have an RGB format. In the current implementation, these are always stored as
		 * CAIRO_FORMAT_ARGB. This makes this section very easy to implement. If native
		 * support for 15- and 16-bit pixel formats needs to be added in the future, though,
		 * then this is where it needs to be done.
		 *
		 * In order to simplify advancing the state->scan pointer, the state->pixels_per_byte
		 * member is set to the number of bytes per pixel, negated. That is, for 24-bit
		 * formats, it is set to -3, and for 32-bit formats, it is set to -4.
		 *
		 * Note that pixel streams do not support 48- and 64-bit data at this time.
		 */
		ret = *(unsigned int *)state->scan;

		/* Special case: 24-bit data needs to have the cairo format alpha component forced
		 * to 0xFF, or many operations will do nothing (or do strange things if the alpha
		 * channel contains garbage).
		 */
		if (state->data->pixel_format == Format24bppRgb) {
			int force_alpha;
			set_pixel_bgra(&force_alpha, 0,
				0, 0, 0, 0xFF);
			ret |= force_alpha;
		}

		state->scan -= state->pixels_per_byte;
		state->x++;

		if (state->x >= (state->region.X + state->region.Width)) {
			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x * -state->pixels_per_byte;
		}
	}

	return ret;
}

void
gdip_pixel_stream_set_next (StreamingState *state, unsigned int pixel_value)
{
	if (state == NULL) {
		return;
	}

	/* Note: This function does not check whether the end of the region has been hit. This function can
	 * potentially overrun memory buffers! gdip_pixel_stream_has_next () must be used in conjunction
	 * with this function.
	 */

	if (state->pixels_per_byte == 1) {
		/* A fast path for 8-bit indexed data: pixels are byte-aligned, so no special packing is required. */
		*state->scan = pixel_value & 0xFF;

		state->scan++;
		state->x++;

		if (state->x >= (state->region.X + state->region.Width)) {
			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x;
		}
	} else if (state->pixels_per_byte > 0) {
		/* We have an indexed format (the RGB formats can't fit a whole pixel into a single byte). */
		if (state->p < 0) {
			state->p = 0;

			if (state->x == state->region.X) {
				/* First pixel of the row; check whether it is aligned to the byte or not. */
				int index_into_byte = state->x & (state->pixels_per_byte - 1);

				if (index_into_byte == 0) {
					/* It is aligned; all we need to do is clear the buffer. */
					state->buffer = 0;
				}
				else {
					/* It is not aligned; the buffer needs to be pre-loaded with those
					 * pixels that are to the left of the first pixel to be set.
					 */
					state->buffer = (*state->scan << (index_into_byte * state->one_pixel_shift));
					state->p = index_into_byte;
				}
			}
		}

		state->buffer <<= state->one_pixel_shift;
		state->buffer |= ((pixel_value & state->one_pixel_mask) << 8);

		state->x++;
		state->p++;

		/* Have we hit the end of the buffer? */
		if (state->p >= state->pixels_per_byte)	{
			*state->scan = (state->buffer >> 8);
			state->scan++;
			state->p = -1;
		}

		if (state->x >= (state->region.X + state->region.Width)) {
			if (state->p >= 0) {
				int existing_mask = 0;

				while (state->p < state->pixels_per_byte) {
					existing_mask <<= state->one_pixel_shift;
					existing_mask |= state->one_pixel_mask;

					state->buffer <<= state->one_pixel_shift;
					state->p++;
				}

				*state->scan = (*state->scan & existing_mask) | (state->buffer >> 8);
			}

			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x * gdip_get_pixel_format_bpp (state->data->pixel_format) / 8;

			state->p = -1;
		}
	} else {
		/* We have an RGB format. In the current implementation, these are always stored as
		 * CAIRO_FORMAT_ARGB. This makes this section very easy to implement. If native
		 * support for 15- and 16-bit pixel formats needs to be added in the future, though,
		 * then this is where it needs to be done.
		 *
		 * In order to simplify advancing the state->scan pointer, the state->pixels_per_byte
		 * member is set to the number of bytes per pixel, negated. That is, for 24-bit
		 * formats, it is set to -3, and for 32-bit formats, it is set to -4.
		 *
		 * Note that pixel streams do not support 48- and 64-bit data at this time.
		 */
		*(unsigned int *)state->scan = pixel_value;

		state->scan -= state->pixels_per_byte;
		state->x++;

		if (state->x >= (state->region.X + state->region.Width)) {
			state->x = state->region.X;
			state->y++;

			state->scan = (unsigned char *)(state->data->scan0)
			            + state->y * state->data->stride
			            + state->x * -state->pixels_per_byte;
		}
	}
}

/**
 * srcData - input data
 * srcRect - rectangle of input data to place in destData
 * destData - where to place output; only the PixelFormat field is needed,
 *            which specifies the output type.
 * destRect - destination rectangle in output.
 *
 * assumes that the pixel format conversion has already been validated.
 */

GpStatus
gdip_bitmap_change_rect_pixel_format (GdipBitmapData *srcData, Rect *srcRect, GdipBitmapData *destData, Rect *destRect)
{
	PixelFormat	srcFormat;
	PixelFormat	destFormat;
	StreamingState	srcStream;
	StreamingState	destStream;
	Rect		effectiveDestRect;
	GpStatus	status;

	if ((srcData == NULL) || (srcRect == NULL) || (destData == NULL) || (destRect == NULL)) {
		return InvalidParameter;
	}

	if ((srcRect->X < 0) || (srcRect->Y < 0) || (srcRect->X >= srcData->width) || (srcRect->Y >= srcData->height)) {
		return InvalidParameter;
	}

	if ((srcRect->X + srcRect->Width > srcData->width) || (srcRect->Y + srcRect->Height > srcData->height)) {
		return InvalidParameter;
	}

	if ((destRect->X < 0) || (destRect->Y < 0) || (srcRect->Width > destRect->Width) || (srcRect->Height > destRect->Height)) {
		return InvalidParameter;
	}

	srcFormat = srcData->pixel_format;
	destFormat = destData->pixel_format;

	if (!gdip_is_pixel_format_conversion_valid (srcFormat, destFormat)) {
		return InvalidParameter;
	}

	if (destData->scan0 == NULL) {
		int	scans;
		int	row_bits;
		int	row_bytes;
		int	stride;
		void	*dest_scan0;

		/* Allocate a buffer on behalf of the caller. */
		scans = destRect->Y + destRect->Height;

		row_bits = destRect->Width * gdip_get_pixel_format_bpp (destFormat);
		row_bytes = (row_bits + 7) / 8;
		stride = (row_bytes + sizeof(pixman_bits_t) - 1) & ~(sizeof(pixman_bits_t) - 1);
		dest_scan0 = GdipAlloc(stride * scans);

		if (dest_scan0 == NULL) {
			return OutOfMemory;
		}

		destData->width = destRect->X + destRect->Width;
		destData->height = destRect->Y + destRect->Height;
		destData->stride = stride;
		destData->scan0 = dest_scan0;
		destData->reserved = GBD_OWN_SCAN0;
	} else {
		/* Check that the destRect lies fully within the destData buffer. */
		if ((destRect->X + destRect->Width > destData->width) || (destRect->Y + destRect->Height > destData->height)) {
			return InvalidParameter;
		}
	}

	effectiveDestRect = *destRect;

	if (effectiveDestRect.Width > srcRect->Width) {
		effectiveDestRect.Width = srcRect->Width;
	}

	if (effectiveDestRect.Height > srcRect->Height) {
		effectiveDestRect.Height = srcRect->Height;
	}

	/* Fire up the pixel streams. */
	status = gdip_init_pixel_stream (&srcStream, srcData, srcRect->X, srcRect->Y, srcRect->Width, srcRect->Height);

	if (status != Ok) {
		return status;
	}

	status = gdip_init_pixel_stream (&destStream, destData, effectiveDestRect.X, effectiveDestRect.Y, effectiveDestRect.Width, effectiveDestRect.Height);

	if (status != Ok) {
		return status;
	}

	/* Move the data; special path going from indexed to not-indexed */
	if ((srcFormat & PixelFormatIndexed) && !(destFormat & PixelFormatIndexed)) {
		int	pixel;

		while (gdip_pixel_stream_has_next (&srcStream)) {
			pixel = gdip_pixel_stream_get_next (&srcStream);

			/* Look up the pixel in the palette and get the ARGB value */
			pixel = srcData->palette->Entries[pixel];
			gdip_pixel_stream_set_next (&destStream, pixel);
		}
	} else {
		while (gdip_pixel_stream_has_next (&srcStream)) {
			gdip_pixel_stream_set_next (&destStream, gdip_pixel_stream_get_next (&srcStream));
		}
	}

	return Ok;
}


BOOL
gdip_is_a_32bit_pixelformat (PixelFormat format)
{
	switch (format) {
		case Format32bppRgb:
		case Format32bppArgb:
		case Format32bppPArgb: /* all of these use CAIRO_FORMAT_ARGB, which is 4 bytes wide */
			return TRUE;
		default:
			return FALSE;
	}
}

BOOL
gdip_is_an_alpha_pixelformat (PixelFormat format)
{
	return ((format & PixelFormatAlpha) != 0);
}

BOOL
gdip_can_window_without_copy (BitmapData *data, Rect *rect, int format)
{
	int bpp = gdip_get_pixel_format_bpp (format);

	if (format != data->pixel_format) {
		/* can't possibly reinterpret bits from one indexed pixel
		 * format as being of another indexed pixel format...
		 */
		if (gdip_is_an_indexed_pixelformat (format) || gdip_is_an_indexed_pixelformat (data->pixel_format)) {
			return FALSE;
		}

		/* ...but we can probably handle 24-bit<->32-bit and
		 * 32-bit alpha<->32-bit opaque without copying data,
		 * since these are all stored as CAIRO_FORMAT_ARGB
		 * internally.
		 */
		if (!gdip_is_a_32bit_pixelformat (format) || !gdip_is_a_32bit_pixelformat (data->pixel_format)) {
			return FALSE;
		}
	}

	/* okay, so the pixel formats are compatible. now, make sure
	 * the rectangle lies on byte boundaries; if it doesn't, then
	 * pixels will have to be shuffled. =/
	 */

	/* 8bpp and above are guaranteed to be byte-aligned */
	if (bpp >= 8) {
		return TRUE;
	} else {
		int left_bit_offset = rect->X * bpp;
		int width_bit_count = rect->Width * bpp;

		/* check whether the values are byte-aligned */
		return ((left_bit_offset & 7) | (width_bit_count & 7)) == 0;
	}
}

void
gdip_make_alpha_opaque (BitmapData *data)
{
	unsigned char	*scan0;
	int		y;
	int		x;
	int		o;
	int		f;

	/* sanity check; make sure we aren't mangling any image data */
	if ((data->pixel_format != Format32bppArgb) && (data->pixel_format != Format32bppRgb)) {
		return;
	}

	scan0 = (unsigned char *)data->scan0;

	f = data->stride - 4 * data->width;

	for (y = 0, o = 0; y < data->height; y++, o += f) {
		for (x = 0; x < data->width; x++, o += 4) {
			scan0[o + 3] = 0xff; /* set alpha to fully-opaque */
		}
	}
}

GpStatus
GdipBitmapLockBits (GpBitmap *bitmap, Rect *srcRect, int flags, int format, GdipBitmapData *locked_data)
{
	int		dest_pixel_format_bpp;
	int		dest_stride;
	int		dest_size;
	unsigned char	*dest_scan0;
	Rect		destRect = { 0, 0, srcRect->Width, srcRect->Height };
	GpStatus	status;
	BitmapData	*root_data;

	if ((bitmap == NULL) || (srcRect == NULL) || (flags == 0) || (locked_data == NULL)) {
		return InvalidParameter;
	}

	root_data = bitmap->active_bitmap;

	/* Is this bitmap already locked? */
	if (root_data->reserved & GBD_LOCKED) {
		return InvalidParameter;
	}

	/* Make sure the srcRect makes sense */
	if ((srcRect->X < 0) || (srcRect->Y < 0) || (srcRect->Width < 0) || (srcRect->Height < 0)) {
		return InvalidParameter;
	}

	if (((srcRect->X + srcRect->Width) > root_data->width) || ((srcRect->Y + srcRect->Height) > root_data->height)) {
		return InvalidParameter;
	}

	if (gdip_is_a_supported_pixelformat (format) == FALSE) {
		return NotImplemented;
	}

	/* Common stuff */
	if ((flags & ImageLockModeWrite) != 0) {
		locked_data->reserved |= GBD_WRITE_OK;
		locked_data->image_flags &= ~ImageFlagsReadOnly;
	} else {
		locked_data->reserved &= ~GBD_WRITE_OK;
		locked_data->image_flags |= ImageFlagsReadOnly;
	}

	if ((format & PixelFormatAlpha) != 0) {
		locked_data->image_flags |= ImageFlagsHasAlpha;
	}

	locked_data->reserved |= GBD_LOCKED;
	locked_data->reserved |= GBD_OWN_SCAN0;
	root_data->reserved |= GBD_LOCKED;

	dest_pixel_format_bpp = gdip_get_pixel_format_bpp (format);
	dest_stride = (srcRect->Width * dest_pixel_format_bpp + 7) / 8;
	dest_size = srcRect->Height * dest_stride;

	if ((flags & ImageLockModeUserInputBuf) == 0) {
		locked_data->scan0 = GdipAlloc(dest_size);
		if (locked_data->scan0 == NULL) {
			return OutOfMemory;
		}
	} else {
		/* User is supposed to have provided the buffer */
		if (locked_data->scan0 == NULL) {
			return InvalidParameter;
		}
		locked_data->reserved &= ~GBD_OWN_SCAN0;
	}

	locked_data->width = srcRect->Width;
	locked_data->height = srcRect->Height;
	locked_data->stride = dest_stride;
	locked_data->pixel_format = format;
	locked_data->x = srcRect->X;
	locked_data->y = srcRect->Y;


	/* If the user wants the original data to be readable, then convert the bits. */
	status = Ok;
	if ((flags & ImageLockModeRead) != 0) {
		status = gdip_bitmap_change_rect_pixel_format (root_data, srcRect, locked_data, &destRect);
		/* Even if this fails, we don't free scan0, that will be taken care by who created it */
	}

	return status;
}

GpStatus 
GdipBitmapUnlockBits (GpBitmap *bitmap, GdipBitmapData *locked_data)
{
	GpStatus	status;
	BitmapData	*root_data;;

	if ((bitmap == NULL) || (locked_data == NULL)) {
		return InvalidParameter;
	}

	/* It is not safe to assume that the correct BitmapData has been passed in.
	 * Sanity check: Make sure the locked data is in fact locked.*/
	if (!(bitmap->active_bitmap->reserved & GBD_LOCKED) || !(locked_data->reserved & GBD_LOCKED)) {
		return InvalidParameter;
	}

	status = Ok;
	root_data = bitmap->active_bitmap;

	/* Sanity check: Make sure the locked data's size is consistent with having
	 * been returned from LockBits (). */
	if ((locked_data->width > root_data->width) || (locked_data->height > root_data->height)) {
		return InvalidParameter;
	}

	/* We need to copy the locked data back to the root data's Scan0 if the image was writeable */
	if ((locked_data->reserved & GBD_WRITE_OK) != 0) {
		Rect srcRect = { 0, 0, locked_data->width, locked_data->height };
		Rect destRect = { locked_data->x, locked_data->y, locked_data->width, locked_data->height };

		status = gdip_bitmap_change_rect_pixel_format (locked_data, &srcRect, root_data, &destRect);
	}

	if ((locked_data->reserved & GBD_OWN_SCAN0) != 0) {
		GdipFree(locked_data->scan0);
		locked_data->scan0 = NULL;
		locked_data->reserved &= ~GBD_OWN_SCAN0;
	}

	if (locked_data->palette) {
		GdipFree(locked_data->palette);
		locked_data->palette = NULL;
	}

	locked_data->reserved &= ~GBD_LOCKED;
	root_data->reserved &= ~GBD_LOCKED;

	return status;
}

GpStatus
GdipBitmapSetPixel (GpBitmap *bitmap, int x, int y, ARGB color)
{
	BitmapData	*data;
	unsigned char	*v;
	
	if ((bitmap == NULL) || (bitmap->active_bitmap == NULL)) {
		return InvalidParameter;
	}
	
	data = bitmap->active_bitmap;

	if ((x < 0) || (x > data->width) || (y < 0) || (y > data->height) || (data->reserved & GBD_LOCKED)) {
		return InvalidParameter;
	}

	if (gdip_is_an_indexed_pixelformat (data->pixel_format)) {
		return InvalidParameter;
	}

	v = (unsigned char *)(data->scan0) + y * data->stride;
	switch (data->pixel_format) {
		case Format24bppRgb:
		case Format32bppRgb:
			color |= 0xFF000000; /* force the alpha for Cairo */
			/* fall through */
		case Format32bppArgb:
		case Format32bppPArgb: {
			ARGB *scan = (ARGB *)v;

			scan[x] = color;
			break;
		}

		default: {
			return NotImplemented;
		}
	} 

	return Ok;		
}

GpStatus
GdipBitmapGetPixel (GpBitmap *bitmap, int x, int y, ARGB *color)
{
	BitmapData	*data;
	
	if ((bitmap == NULL) || (bitmap->active_bitmap == NULL) || (color == NULL)) {
		return InvalidParameter;
	}

	data = bitmap->active_bitmap;

	if ((x < 0) || (x >= data->width) || (y < 0) || (y >= data->height) || (data->reserved & GBD_LOCKED)) {
		return InvalidParameter;
	}

	if (gdip_is_an_indexed_pixelformat (data->pixel_format)) {
		StreamingState	pixel_stream;
		GpStatus	status;
		unsigned int	palette_index;

		if (data->palette == NULL) {
			return InvalidParameter;
		}

		status = gdip_init_pixel_stream (&pixel_stream, data, x, y, 1, 1);

		if (status != Ok) {
			return status;
		}

		palette_index = gdip_pixel_stream_get_next (&pixel_stream);

		if (palette_index >= data->palette->Count) {
			return InvalidParameter;
		}

		*color = data->palette->Entries[palette_index];
	} else {
		unsigned char *v;

		v = ((unsigned char *)data->scan0) + y * data->stride;
		switch (data->pixel_format) {
			case Format24bppRgb:
			case Format32bppArgb:
			case Format32bppPArgb:
			case Format32bppRgb: {
				ARGB *scan = (ARGB *)v;

				*color = scan[x];
				break;
			}

			default: {
				return NotImplemented;
			}
		}
	} 
	
	return Ok;
}

GpStatus
GdipBitmapSetResolution (GpBitmap *bitmap, float xdpi, float ydpi)
{
	if ((bitmap == NULL) || (bitmap->active_bitmap == NULL)) {
		return InvalidParameter;
	}

	bitmap->active_bitmap->dpi_horz = xdpi;
	bitmap->active_bitmap->dpi_vert = ydpi;

	bitmap->active_bitmap->image_flags |= ImageFlagsHasRealDPI;

	return Ok;
}

cairo_surface_t *
gdip_bitmap_ensure_surface (GpBitmap *bitmap)
{
	BitmapData	*data;

	data= bitmap->active_bitmap;

	if ((bitmap->surface == NULL) && (data != NULL) && (data->scan0 != NULL)) {
		switch (data->pixel_format) {
			case Format24bppRgb: {
				bitmap->surface = cairo_image_surface_create_for_data(
							(unsigned char *)data->scan0,
							CAIRO_FORMAT_RGB24, 
							data->width, 
							data->height, 
							data->stride);
				break;
			}

			case Format32bppArgb:
			case Format32bppRgb:
			case Format32bppPArgb: {
				bitmap->surface = cairo_image_surface_create_for_data(
							(unsigned char *)data->scan0,
							CAIRO_FORMAT_ARGB32,
							data->width, 
							data->height, 
							data->stride);
				break;
			}

			default: {
				g_warning ("gdip_bitmap_ensure_surface: Unable to create a surface for raw bitmap data of format 0x%08x", data->pixel_format);
				break;
			}
		}
	}

	return bitmap->surface;
}

GpBitmap *
gdip_convert_indexed_to_rgb (GpBitmap *indexed_bmp)
{
	BitmapData	*data;
	ColorPalette	*palette;
	int		rgb_stride;
	int		rgb_bytes;
	int		force_alpha;
	int		one_pixel_mask;
	int		one_pixel_shift;
	int		pixels_per_byte;
	int		*rgb_scan0;
	int		p;
	int		x;
	int		y;
	GpBitmap	*ret;
	GpStatus	status;
	unsigned char	*indexed_scan;
	int		*rgb_scan;
	int		pixels_this_byte;
	unsigned short	sample;
	int		index;
	int		transparent;
	int		format;

	data = indexed_bmp->active_bitmap;
	if (data == NULL) {
		return NULL;
	}

	palette = data->palette;

	if (palette == NULL || !gdip_is_an_indexed_pixelformat (data->pixel_format)) {
		return NULL;
	}

	switch (data->pixel_format) {
		case Format1bppIndexed: one_pixel_mask = 0x01; one_pixel_shift = 1; pixels_per_byte = 8; break;
		case Format4bppIndexed: one_pixel_mask = 0x0F; one_pixel_shift = 4; pixels_per_byte = 2; break;
		case Format8bppIndexed: one_pixel_mask = 0xFF; one_pixel_shift = 8; pixels_per_byte = 1; break;
		default: /* something is wrong!! */
			return NULL;
	}

	if ((palette->Flags & PaletteFlagsHasAlpha) == 0) {
		format = Format32bppRgb;
		set_pixel_bgra (&force_alpha, 0, 0, 0, 0, 0xFF); /* full alpha bits set */
	} else {
		format = Format32bppArgb;
		force_alpha = 0;
	}

	rgb_stride = data->width * 4;

	/* ensure pixman_bits_t alignment */
	rgb_stride += (sizeof(pixman_bits_t)-1);
	rgb_stride &= ~(sizeof(pixman_bits_t)-1);

	rgb_bytes = data->height * rgb_stride;

	/* allocate the RGB frame */
	rgb_scan0 = GdipAlloc (rgb_bytes);

	if (rgb_scan0 == NULL) { /* out of memory?? */
		return NULL;
	}

	/* convert the indexed pixels into RGB values and store them into the RGB frame */
	for (y=0; y < data->height; y++) {
		indexed_scan = (unsigned char *)(data->scan0) + y * data->stride;
		rgb_scan = rgb_scan0 + (y * rgb_stride) / sizeof(int);

		for (x=0; x < data->width; x += pixels_per_byte) {
			pixels_this_byte = pixels_per_byte;
			sample = *indexed_scan;

			indexed_scan++;

			if (x + pixels_this_byte >= data->width) {
				pixels_this_byte = data->width - x;
			}

			for (p=0; p < pixels_this_byte; p++) {
				sample <<= one_pixel_shift;
				index = (sample >> 8) & one_pixel_mask;

				rgb_scan[x + p] = palette->Entries[index] | force_alpha;
			}
		}
	}

	/* try to get a GpBitmap out of it :-) */
	status = GdipCreateBitmapFromScan0 (data->width, data->height, rgb_stride, format, rgb_scan0, &ret);
	if (status == Ok) {
		return ret;
	}

	if (ret != NULL) {
		gdip_bitmap_dispose(ret);
	}
	if (rgb_scan0 != NULL) {
		GdipFree (rgb_scan0);
	}
	return NULL;
}

